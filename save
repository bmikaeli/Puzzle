// ************************************************************************** //
//                                                                            //
//                                                        :::      ::::::::   //
//   Resolve.cpp                                        :+:      :+:    :+:   //
//                                                    +:+ +:+         +:+     //
//   By: mbar <mbar@student.42.fr>                  +#+  +:+       +#+        //
//                                                +#+#+#+#+#+   +#+           //
//   Created: 2015/03/09 16:07:47 by mbar              #+#    #+#             //
//   Updated: 2015/03/10 18:15:49 by mbar             ###   ########.fr       //
//                                                                            //
// ************************************************************************** //

#include "Resolve.hpp"

Resolve::Resolve(std::vector<size_t> map, size_t size) : map(map), size(size)
{
	return ;
}

Resolve::Resolve(Resolve const &src)
{
	*this = src;
	return ;
}

Resolve::~Resolve(void)
{
	return ;
}

Resolve							&Resolve::operator=(Resolve const &rhs)
{
	if (this != &rhs)
	{
	}
	return *this;
}

bool							Resolve::is_final(t_node next)
{
	size_t						i = 0;
	while (i < this->map.size() - 1)
	{
		if (next.cur_map[i] != (i + 1))
			return (false);
		i++;
	}
	return (true);
}

//void							Resolve::add_to_queue(std::vector<t_node> *queue, t_node next, std::vector<t_node> &old, size_t g)
void							Resolve::add_to_queue(std::vector<t_node> *queue, t_node next, std::map<int, std::vector<t_node> > &old, size_t g)
{
	t_node						temp;
	size_t						i = 0;

	while (next.cur_map[i] != 0)
		i++;
	if ((i % this->size) != (this->size - 1))
	{
		temp.cur_map = next.cur_map;
		temp.cur_map[i] = temp.cur_map[i + 1];
		temp.cur_map[i + 1] = 0;
//		temp.i = old.size() - 1;
		temp.g = g;
		temp.h = this->sum_heuristic_m(temp.cur_map);
		temp.f = temp.g + temp.h;
		temp.i = old[next.h % MAX].size() - 1;
		temp.j = next.h % MAX;
//		if (!this->is_exist(old, temp))
//			queue->push_back(temp);
		if (!this->is_exist(old[temp.h % MAX], temp))
			queue->push_back(temp);
//			queue->insert(queue->begin(), temp);
	}
	if ((i % this->size) != 0)
	{
		temp.cur_map = next.cur_map;
		temp.cur_map[i] = temp.cur_map[i - 1];
		temp.cur_map[i - 1] = 0;
//		temp.i = old.size() - 1;
		temp.g = g;
		temp.h = this->sum_heuristic_m(temp.cur_map);
		temp.f = temp.g + temp.h;
		temp.i = old[next.h % MAX].size() - 1;
		temp.j = next.h % MAX;
//		if (!this->is_exist(old, temp))
//			queue->push_back(temp);
		if (!this->is_exist(old[temp.h % MAX], temp))
			queue->push_back(temp);
//			queue->insert(queue->begin(), temp);
	}
	if ((i / this->size) != (this->size - 1))
	{
		temp.cur_map = next.cur_map;
		temp.cur_map[i] = temp.cur_map[i + this->size];
		temp.cur_map[i + this->size] = 0;
//		temp.i = old.size() - 1;
		temp.g = g;
		temp.h = this->sum_heuristic_m(temp.cur_map);
		temp.f = temp.g + temp.h;
		temp.i = old[next.h % MAX].size() - 1;
		temp.j = next.h % MAX;
//		if (!this->is_exist(old, temp))
//			queue->push_back(temp);
		if (!this->is_exist(old[temp.h % MAX], temp))
			queue->push_back(temp);
//			queue->insert(queue->begin(), temp);
	}
	if ((i / this->size) != 0)
	{
		temp.cur_map = next.cur_map;
		temp.cur_map[i] = temp.cur_map[i - this->size];
		temp.cur_map[i - this->size] = 0;
//		temp.i = old.size() - 1;
		temp.g = g;
		temp.h = this->sum_heuristic_m(temp.cur_map);
		temp.f = temp.g + temp.h;
		temp.i = old[next.h % MAX].size() - 1;
		temp.j = next.h % MAX;
//		if (!this->is_exist(old, temp))
//			queue->push_back(temp);
		if (!this->is_exist(old[temp.h % MAX], temp))
			queue->push_back(temp);
//			queue->insert(queue->begin(), temp);
	}
}

bool							Resolve::is_exist(std::vector<t_node> list, t_node item)
{
	size_t						i = 0;

	while (i < list.size())
	{
		if (item.cur_map == list[i].cur_map)
			return (true);
		i++;
	}
	return (false);
}

void							Resolve::sort_queue(std::vector<t_node> &queue)
{
	t_node						temp;
	size_t						i = 0;
	size_t						j;

	while (i < queue.size())
	{
		j = i;
		while (j < queue.size())
		{
			if (queue[i].h > queue[j].h)
			{
				temp = queue[i];
				queue[i] = queue[j];
				queue[j] = temp;
			}
			else if (queue[i].h == queue[j].h)
			{
				if (queue[i].f > queue[j].f)
				{
					temp = queue[i];
					queue[i] = queue[j];
					queue[j] = temp;
				}
			}
			j++;
		}
		i++;
	}
}

t_node							Resolve::find_next(std::vector<t_node> &queue)
{
//	size_t						i = 0;
//	size_t						s = 0;
	std::vector<t_node>::iterator ite = queue.end();
	std::vector<t_node>::iterator it = queue.begin();
	std::vector<t_node>::iterator ret = queue.begin();
	t_node r;
while (it != ite)
	{
		if ((*it).h < (*ret).h) //<queue[i].h < queue[s].h)
			ret = it;
		else if ((*it).h == (*ret).h) //queue[i].h == queue[s].h)
		{
			if ((*it).f < (*ret).f)
				ret = it;
		}
		it++;
	}
r = *ret;
queue.erase(ret);

	return (r);
}

void							Resolve::launch(void)
{
	if (!this->is_solvable())
	{
		std::cerr << "This puzzle is unsolvable." << std::endl;
		return ;
	}

	std::vector<t_node>			queue;
	std::vector<t_node>			old;
	t_node						initial;
	t_node						next;
	size_t						g = 0;
	bool						cont = true;

	std::map<int, std::vector<t_node> >	test;
	initial.cur_map = this->map;
	initial.i = -1;
	initial.j = -1;
	initial.g = 0;
	initial.h = 0;
	initial.f = 0;
	queue.push_back(initial);
	while (queue.size() > 0 && cont)
	{
//		next = queue[0];
		next = this->find_next(queue);
//		if (!this->is_exist(old, next))
// 			old.push_back(next);
		test[next.h % MAX].push_back(next);
//		queue.erase(queue.begin());
		if (this->is_final(next))
			cont = false;
		else
		{
			g += 1;
			std::cout << g << std::endl;
//			add_to_queue(&queue, next, old, g);
			add_to_queue(&queue, next, test, g);
//			sort_queue(queue);
		}
	}
	if (!cont)
//		this->aff_result(next, old);
		this->aff_result(next, test);
}

void							Resolve::aff_result(t_node last, std::map<int, std::vector<t_node> > old)
{
	if (last.i != -1)
		this->aff_result(old[last.j][last.i], old);
	aff_map(last.cur_map);
	if (!this->is_final(last))
		std::cout << std::endl;
}

void							Resolve::aff_map(std::vector<size_t> map)
{
	size_t						i = 0;

	while (i < map.size())
	{
		std::cout << map[i];
		if ((i % this->size) != (this->size - 1))
			std::cout << " ";
		else
			std::cout << std::endl;
		i++;
	}
}

size_t							Resolve::sum_heuristic_m(std::vector<size_t> map)
{
	size_t						r = 0;
	size_t						i = 0;

	while (i < map.size() - 1)
	{
		r += this->heuristic_m(i + 1, i, map);
		i++;
	}
	return (r);
}

size_t							Resolve::heuristic_m(size_t n, size_t pos, std::vector<size_t> map)
{
	size_t						p = 0;
	size_t						i = 0;

	while (map[i] != n)
		i++;
	if ((i % this->size) > (pos % this->size))
		p += (i % this->size) - (pos % this->size);
	else
		p += (pos % this->size) - (i % this->size);
	if ((i / this->size) > (pos / this->size))
		p += (i / this->size) - (pos / this->size);
	else
		p += (pos / this->size) - (i / this->size);
	return (p);
}

bool							Resolve::is_solvable(void)
{
	std::vector<size_t>			cpy;
	size_t						p = 0;
	size_t						i = 0;
	size_t						j = 0;
	size_t						temp;

	cpy = this->map;
	while (cpy[i] != 0)
		i++;
	if (i != (cpy.size() - 1))
	{
		p++;
		cpy[i] = cpy[cpy.size() - 1];
		cpy[cpy.size() - 1] = 0;
	}
	i = 0;
	while (i < (cpy.size() - 1))
	{
		if (cpy[i] != i + 1)
		{
			p++;
			j = 0;
			while (cpy[j] != (i + 1))
				j++;
			temp = cpy[i];
			cpy[i] = cpy[j];
			cpy[j] = temp;
		}
		i++;
	}
	if ((this->heuristic_m(0, this->map.size() - 1, this->map) % 2) != (p % 2))
		return (false);
	return (true);
}
